// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `from`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Db>>
abstract class Db implements RustOpaqueInterface {
  /// Append value to a key, return new length.
  Future<PlatformInt64> append({required String key, required List<int> value});

  /// Get the number of keys in the database.
  Future<PlatformInt64> dbsize();

  /// Decrement the integer value of a key by one.
  Future<PlatformInt64> decr({required String key});

  /// Decrement the integer value of a key by amount.
  Future<PlatformInt64> decrby({
    required String key,
    required PlatformInt64 decrement,
  });

  /// Delete one or more keys, return count deleted.
  Future<PlatformInt64> del({required List<String> keys});

  /// Check if keys exist, return count of existing keys.
  Future<PlatformInt64> exists({required List<String> keys});

  /// Set expiration in seconds.
  Future<bool> expire({required String key, required PlatformInt64 seconds});

  /// Set expiration at Unix timestamp (seconds).
  Future<bool> expireat({required String key, required PlatformInt64 unixTime});

  /// Delete all keys in the current database.
  Future<void> flushdb();

  /// Get the value of a key.
  Future<Uint8List?> get_({required String key});

  /// Get and delete a key.
  Future<Uint8List?> getdel({required String key});

  /// Get a substring of the value stored at key.
  Future<Uint8List> getrange({
    required String key,
    required PlatformInt64 start,
    required PlatformInt64 end,
  });

  /// Delete hash fields.
  Future<PlatformInt64> hdel({
    required String key,
    required List<String> fields,
  });

  /// Check if hash field exists.
  Future<bool> hexists({required String key, required String field});

  /// Get a hash field value.
  Future<Uint8List?> hget({required String key, required String field});

  /// Get all fields and values in a hash.
  Future<List<(String, Uint8List)>> hgetall({required String key});

  /// Increment hash field by integer.
  Future<PlatformInt64> hincrby({
    required String key,
    required String field,
    required PlatformInt64 increment,
  });

  /// Get all field names in a hash.
  Future<List<String>> hkeys({required String key});

  /// Get number of fields in a hash.
  Future<PlatformInt64> hlen({required String key});

  /// Get values of multiple hash fields.
  Future<List<Uint8List?>> hmget({
    required String key,
    required List<String> fields,
  });

  /// Set multiple hash fields.
  Future<PlatformInt64> hmset({
    required String key,
    required List<(String, Uint8List)> mapping,
  });

  /// Incrementally iterate hash fields.
  Future<(String, List<(String, Uint8List)>)> hscan({
    required String key,
    required String cursor,
    String? pattern,
    required PlatformInt64 count,
  });

  /// Set a single hash field.
  Future<PlatformInt64> hset({
    required String key,
    required String field,
    required List<int> value,
  });

  /// Get all values in a hash.
  Future<List<Uint8List>> hvals({required String key});

  /// Increment the integer value of a key by one.
  Future<PlatformInt64> incr({required String key});

  /// Increment the integer value of a key by amount.
  Future<PlatformInt64> incrby({
    required String key,
    required PlatformInt64 increment,
  });

  /// Increment the float value of a key by amount.
  Future<double> incrbyfloat({required String key, required double increment});

  /// Get the type of a key.
  Future<KeyType> keyType({required String key});

  /// Find all keys matching a pattern.
  Future<List<String>> keys({required String pattern});

  /// Get element at index in a list.
  Future<Uint8List?> lindex({
    required String key,
    required PlatformInt64 index,
  });

  /// Get list length.
  Future<PlatformInt64> llen({required String key});

  /// Pop values from the left of a list.
  Future<List<Uint8List>> lpop({required String key, PlatformInt64? count});

  /// Push values to the left of a list.
  Future<PlatformInt64> lpush({
    required String key,
    required List<Uint8List> values,
  });

  /// Get a range of elements from a list.
  Future<List<Uint8List>> lrange({
    required String key,
    required PlatformInt64 start,
    required PlatformInt64 stop,
  });

  /// Set element at index in a list.
  Future<void> lset({
    required String key,
    required PlatformInt64 index,
    required List<int> value,
  });

  /// Trim list to specified range.
  Future<void> ltrim({
    required String key,
    required PlatformInt64 start,
    required PlatformInt64 stop,
  });

  /// Get values of multiple keys.
  Future<List<Uint8List?>> mget({required List<String> keys});

  /// Set multiple key-value pairs atomically.
  Future<void> mset({required List<(String, Uint8List)> pairs});

  /// Open a database at the given path.
  /// Use ":memory:" for an in-memory database.
  static Db open({required String path}) =>
      RustLib.instance.api.crateApiDbOpen(path: path);

  /// Open an in-memory database.
  static Db openMemory() => RustLib.instance.api.crateApiDbOpenMemory();

  /// Open a database with custom cache size in MB.
  static Db openWithCache({
    required String path,
    required PlatformInt64 cacheMb,
  }) => RustLib.instance.api.crateApiDbOpenWithCache(
    path: path,
    cacheMb: cacheMb,
  );

  /// Remove expiration from a key.
  Future<bool> persist({required String key});

  /// Set expiration in milliseconds.
  Future<bool> pexpire({
    required String key,
    required PlatformInt64 milliseconds,
  });

  /// Set expiration at Unix timestamp (milliseconds).
  Future<bool> pexpireat({
    required String key,
    required PlatformInt64 unixTimeMs,
  });

  /// Set key with expiration in milliseconds.
  Future<void> psetex({
    required String key,
    required PlatformInt64 milliseconds,
    required List<int> value,
  });

  /// Get TTL in milliseconds.
  Future<PlatformInt64> pttl({required String key});

  /// Rename a key.
  Future<void> rename({required String key, required String newkey});

  /// Rename a key only if newkey does not exist.
  Future<bool> renamenx({required String key, required String newkey});

  /// Pop values from the right of a list.
  Future<List<Uint8List>> rpop({required String key, PlatformInt64? count});

  /// Push values to the right of a list.
  Future<PlatformInt64> rpush({
    required String key,
    required List<Uint8List> values,
  });

  /// Add members to a set.
  Future<PlatformInt64> sadd({
    required String key,
    required List<Uint8List> members,
  });

  /// Incrementally iterate keys matching a pattern.
  Future<(String, List<String>)> scan({
    required String cursor,
    String? pattern,
    required PlatformInt64 count,
  });

  /// Get number of members in a set.
  Future<PlatformInt64> scard({required String key});

  /// Get difference between sets.
  Future<List<Uint8List>> sdiff({required List<String> keys});

  /// Set a key-value pair with optional TTL in seconds.
  Future<void> set_({
    required String key,
    required List<int> value,
    PlatformInt64? ttlSeconds,
  });

  /// Set a key-value pair with options (NX, XX, EX, PX).
  Future<bool> setOpts({
    required String key,
    required List<int> value,
    required SetOptions options,
  });

  /// Set key with expiration in seconds.
  Future<void> setex({
    required String key,
    required PlatformInt64 seconds,
    required List<int> value,
  });

  /// Overwrite part of a string at key starting at offset.
  Future<PlatformInt64> setrange({
    required String key,
    required PlatformInt64 offset,
    required List<int> value,
  });

  /// Get intersection of sets.
  Future<List<Uint8List>> sinter({required List<String> keys});

  /// Check if member is in a set.
  Future<bool> sismember({required String key, required List<int> member});

  /// Get all members of a set.
  Future<List<Uint8List>> smembers({required String key});

  /// Remove members from a set.
  Future<PlatformInt64> srem({
    required String key,
    required List<Uint8List> members,
  });

  /// Incrementally iterate set members.
  Future<(String, List<Uint8List>)> sscan({
    required String key,
    required String cursor,
    String? pattern,
    required PlatformInt64 count,
  });

  /// Get the length of the value stored at key.
  Future<PlatformInt64> strlen({required String key});

  /// Get union of sets.
  Future<List<Uint8List>> sunion({required List<String> keys});

  /// Get TTL in seconds.
  Future<PlatformInt64> ttl({required String key});

  /// Run SQLite VACUUM to reclaim space.
  Future<PlatformInt64> vacuum();

  /// Add members with scores to a sorted set.
  Future<PlatformInt64> zadd({
    required String key,
    required List<ZMember> members,
  });

  /// Get number of members in a sorted set.
  Future<PlatformInt64> zcard({required String key});

  /// Count members in a sorted set within a score range.
  Future<PlatformInt64> zcount({
    required String key,
    required double minScore,
    required double maxScore,
  });

  /// Increment score of a member in a sorted set.
  Future<double> zincrby({
    required String key,
    required double increment,
    required List<int> member,
  });

  /// Get members by rank range (ascending order).
  Future<List<ZMember>> zrange({
    required String key,
    required PlatformInt64 start,
    required PlatformInt64 stop,
    required bool withScores,
  });

  /// Get rank of a member in a sorted set (ascending order).
  Future<PlatformInt64?> zrank({
    required String key,
    required List<int> member,
  });

  /// Remove members from a sorted set.
  Future<PlatformInt64> zrem({
    required String key,
    required List<Uint8List> members,
  });

  /// Get members by rank range (descending order).
  Future<List<ZMember>> zrevrange({
    required String key,
    required PlatformInt64 start,
    required PlatformInt64 stop,
    required bool withScores,
  });

  /// Get rank of a member in a sorted set (descending order).
  Future<PlatformInt64?> zrevrank({
    required String key,
    required List<int> member,
  });

  /// Incrementally iterate sorted set members with scores.
  Future<(String, List<(Uint8List, double)>)> zscan({
    required String key,
    required String cursor,
    String? pattern,
    required PlatformInt64 count,
  });

  /// Get score of a member in a sorted set.
  Future<double?> zscore({required String key, required List<int> member});
}

/// Key type enum
enum KeyType { string, list, set_, hash, zSet, stream, none }

/// Error type for Redlite operations
class RedliteError implements FrbException {
  final String message;

  const RedliteError({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedliteError &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

/// Set options for SET command
@freezed
sealed class SetOptions with _$SetOptions {
  const SetOptions._();
  const factory SetOptions({
    PlatformInt64? ex,
    PlatformInt64? px,
    required bool nx,
    required bool xx,
  }) = _SetOptions;
  static Future<SetOptions> default_() =>
      RustLib.instance.api.crateApiSetOptionsDefault();
}

/// Sorted set member with score
@freezed
sealed class ZMember with _$ZMember {
  const factory ZMember({required double score, required Uint8List member}) =
      _ZMember;
}
