/* Auto-generated C bindings for redlite
 * Do not edit manually - regenerate with: cbindgen -c cbindgen.toml -o redlite.h
 */


#ifndef REDLITE_H
#define REDLITE_H

/* Warning: this file is autogenerated. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Opaque handle to a redlite database
 */
typedef struct RedliteDb RedliteDb;

/**
 * Result of operations that return bytes
 */
typedef struct RedliteBytes {
  uint8_t *data;
  size_t len;
} RedliteBytes;

/**
 * Result of operations that return a string array
 */
typedef struct RedliteStringArray {
  char **strings;
  size_t len;
} RedliteStringArray;

/**
 * Result of operations that return bytes array
 */
typedef struct RedliteBytesArray {
  struct RedliteBytes *items;
  size_t len;
} RedliteBytesArray;

/**
 * SCAN result
 */
typedef struct RedliteScanResult {
  char *cursor;
  struct RedliteStringArray keys;
} RedliteScanResult;

/**
 * HSCAN result (field-value pairs)
 */
typedef struct RedliteHScanResult {
  char *cursor;
  struct RedliteBytesArray pairs;
} RedliteHScanResult;

/**
 * SSCAN result
 */
typedef struct RedliteSScanResult {
  char *cursor;
  struct RedliteBytesArray members;
} RedliteSScanResult;

/**
 * ZSCAN member with score
 */
typedef struct RedliteZScanMember {
  struct RedliteBytes member;
  double score;
} RedliteZScanMember;

/**
 * ZSCAN result
 */
typedef struct RedliteZScanResult {
  char *cursor;
  struct RedliteZScanMember *members;
  size_t len;
} RedliteZScanResult;

/**
 * Stream ID (ms-seq)
 */
typedef struct RedliteStreamId {
  int64_t ms;
  int64_t seq;
} RedliteStreamId;

/**
 * Stream entry field
 */
typedef struct RedliteStreamField {
  const uint8_t *key;
  size_t key_len;
  const uint8_t *value;
  size_t value_len;
} RedliteStreamField;

/**
 * Stream entry
 */
typedef struct RedliteStreamEntry {
  struct RedliteStreamId id;
  struct RedliteStreamField *fields;
  size_t fields_len;
} RedliteStreamEntry;

/**
 * Stream entry array
 */
typedef struct RedliteStreamEntryArray {
  struct RedliteStreamEntry *entries;
  size_t len;
} RedliteStreamEntryArray;

/**
 * Consumer group information
 */
typedef struct RedliteConsumerGroupInfo {
  char *name;
  int64_t consumers;
  int64_t pending;
  struct RedliteStreamId last_delivered_id;
} RedliteConsumerGroupInfo;

/**
 * Consumer group info array
 */
typedef struct RedliteConsumerGroupInfoArray {
  struct RedliteConsumerGroupInfo *groups;
  size_t len;
} RedliteConsumerGroupInfoArray;

/**
 * Consumer information
 */
typedef struct RedliteConsumerInfo {
  char *name;
  int64_t pending;
  int64_t idle;
} RedliteConsumerInfo;

/**
 * Consumer info array
 */
typedef struct RedliteConsumerInfoArray {
  struct RedliteConsumerInfo *consumers;
  size_t len;
} RedliteConsumerInfoArray;

/**
 * Stream information
 */
typedef struct RedliteStreamInfo {
  int64_t length;
  int64_t radix_tree_keys;
  int64_t radix_tree_nodes;
  struct RedliteStreamId last_generated_id;
  struct RedliteStreamEntry *first_entry;
  struct RedliteStreamEntry *last_entry;
} RedliteStreamInfo;

/**
 * History entry
 */
typedef struct RedliteHistoryEntry {
  int64_t timestamp;
  struct RedliteBytes value;
} RedliteHistoryEntry;

/**
 * History entry array
 */
typedef struct RedliteHistoryEntryArray {
  struct RedliteHistoryEntry *entries;
  size_t len;
} RedliteHistoryEntryArray;

/**
 * Geospatial member with coordinates
 */
typedef struct RedliteGeoMember {
  char *member;
  double longitude;
  double latitude;
  double dist;
} RedliteGeoMember;

/**
 * Geo member array
 */
typedef struct RedliteGeoMemberArray {
  struct RedliteGeoMember *members;
  size_t len;
} RedliteGeoMemberArray;

/**
 * Geo position (lon, lat)
 */
typedef struct RedliteGeoPos {
  double longitude;
  double latitude;
  int exists;
} RedliteGeoPos;

/**
 * Geo position array
 */
typedef struct RedliteGeoPosArray {
  struct RedliteGeoPos *positions;
  size_t len;
} RedliteGeoPosArray;

/**
 * Key-value pair for hash operations
 */
typedef struct RedliteKV {
  const char *key;
  const uint8_t *value;
  size_t value_len;
} RedliteKV;

/**
 * Sorted set member
 */
typedef struct RedliteZMember {
  double score;
  const uint8_t *member;
  size_t member_len;
} RedliteZMember;

/**
 * Open a database at the given path
 *
 * Returns NULL on error. Call `redlite_last_error` for details.
 */
struct RedliteDb *redlite_open(const char *path);

/**
 * Open an in-memory database
 */
struct RedliteDb *redlite_open_memory(void);

/**
 * Open a database with custom cache size
 */
struct RedliteDb *redlite_open_with_cache(const char *path, int64_t cache_mb);

/**
 * Close a database and free resources
 */
void redlite_close(struct RedliteDb *db);

/**
 * Get the last error message (NULL if no error)
 */
char *redlite_last_error(void);

/**
 * Free a string returned by redlite functions
 */
void redlite_free_string(char *s);

/**
 * Free bytes returned by redlite functions
 */
void redlite_free_bytes(struct RedliteBytes bytes);

/**
 * Free a string array returned by redlite functions
 */
void redlite_free_string_array(struct RedliteStringArray arr);

/**
 * Free a bytes array returned by redlite functions
 */
void redlite_free_bytes_array(struct RedliteBytesArray arr);

/**
 * Free a SCAN result
 */
void redlite_free_scan_result(struct RedliteScanResult result);

/**
 * Free an HSCAN result
 */
void redlite_free_hscan_result(struct RedliteHScanResult result);

/**
 * Free an SSCAN result
 */
void redlite_free_sscan_result(struct RedliteSScanResult result);

/**
 * Free a ZSCAN result
 */
void redlite_free_zscan_result(struct RedliteZScanResult result);

/**
 * Free a stream entry
 */
void redlite_free_stream_entry(struct RedliteStreamEntry entry);

/**
 * Free a stream entry array
 */
void redlite_free_stream_entry_array(struct RedliteStreamEntryArray arr);

/**
 * Free consumer group info array
 */
void redlite_free_consumer_group_info_array(struct RedliteConsumerGroupInfoArray arr);

/**
 * Free consumer info array
 */
void redlite_free_consumer_info_array(struct RedliteConsumerInfoArray arr);

/**
 * Free stream info
 */
void redlite_free_stream_info(struct RedliteStreamInfo info);

/**
 * Free history entry array
 */
void redlite_free_history_entry_array(struct RedliteHistoryEntryArray arr);

/**
 * Free geo member array
 */
void redlite_free_geo_member_array(struct RedliteGeoMemberArray arr);

/**
 * Free geo position array
 */
void redlite_free_geo_pos_array(struct RedliteGeoPosArray arr);

/**
 * GET key
 */
struct RedliteBytes redlite_get(struct RedliteDb *db, const char *key);

/**
 * SET key value [ttl_seconds]
 * Returns 0 on success, -1 on error
 */
int redlite_set(struct RedliteDb *db,
                const char *key,
                const uint8_t *value,
                size_t value_len,
                int64_t ttl_seconds);

/**
 * SETEX key seconds value
 */
int redlite_setex(struct RedliteDb *db,
                  const char *key,
                  int64_t seconds,
                  const uint8_t *value,
                  size_t value_len);

/**
 * PSETEX key milliseconds value
 */
int redlite_psetex(struct RedliteDb *db,
                   const char *key,
                   int64_t milliseconds,
                   const uint8_t *value,
                   size_t value_len);

/**
 * GETDEL key
 */
struct RedliteBytes redlite_getdel(struct RedliteDb *db, const char *key);

/**
 * APPEND key value
 * Returns new length, or -1 on error
 */
int64_t redlite_append(struct RedliteDb *db,
                       const char *key,
                       const uint8_t *value,
                       size_t value_len);

/**
 * STRLEN key
 */
int64_t redlite_strlen(struct RedliteDb *db, const char *key);

/**
 * GETRANGE key start end
 */
struct RedliteBytes redlite_getrange(struct RedliteDb *db,
                                     const char *key,
                                     int64_t start,
                                     int64_t end);

/**
 * SETRANGE key offset value
 */
int64_t redlite_setrange(struct RedliteDb *db,
                         const char *key,
                         int64_t offset,
                         const uint8_t *value,
                         size_t value_len);

/**
 * INCR key
 */
int64_t redlite_incr(struct RedliteDb *db, const char *key);

/**
 * DECR key
 */
int64_t redlite_decr(struct RedliteDb *db, const char *key);

/**
 * INCRBY key increment
 */
int64_t redlite_incrby(struct RedliteDb *db, const char *key, int64_t increment);

/**
 * DECRBY key decrement
 */
int64_t redlite_decrby(struct RedliteDb *db, const char *key, int64_t decrement);

/**
 * INCRBYFLOAT key increment
 * Returns result as string (caller must free), NULL on error
 */
char *redlite_incrbyfloat(struct RedliteDb *db, const char *key, double increment);

/**
 * MGET key [key ...]
 */
struct RedliteBytesArray redlite_mget(struct RedliteDb *db,
                                      const char *const *keys,
                                      size_t keys_len);

/**
 * MSET key value [key value ...]
 */
int redlite_mset(struct RedliteDb *db, const struct RedliteKV *pairs, size_t pairs_len);

/**
 * SETNX key value
 * Returns 1 if key was set, 0 if key already exists
 */
int redlite_setnx(struct RedliteDb *db, const char *key, const uint8_t *value, size_t value_len);

/**
 * GETEX key [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | PERSIST]
 * ex_seconds: >0 to set EX, 0 to ignore
 * px_milliseconds: >0 to set PX, 0 to ignore
 * exat_timestamp: >0 to set EXAT, 0 to ignore
 * pxat_timestamp: >0 to set PXAT, 0 to ignore
 * persist: 1 to set PERSIST, 0 to ignore
 * Only one option should be non-zero/non-false
 */
struct RedliteBytes redlite_getex(struct RedliteDb *db,
                                  const char *key,
                                  int64_t ex_seconds,
                                  int64_t px_milliseconds,
                                  int64_t exat_timestamp,
                                  int64_t pxat_timestamp,
                                  int persist);

/**
 * DEL key [key ...]
 * Returns number of keys deleted
 */
int64_t redlite_del(struct RedliteDb *db, const char *const *keys, size_t keys_len);

/**
 * EXISTS key [key ...]
 */
int64_t redlite_exists(struct RedliteDb *db, const char *const *keys, size_t keys_len);

/**
 * TYPE key
 * Returns type string (caller must free), NULL if key doesn't exist
 */
char *redlite_type(struct RedliteDb *db, const char *key);

/**
 * TTL key
 * Returns -2 if key doesn't exist, -1 if no TTL, otherwise seconds
 */
int64_t redlite_ttl(struct RedliteDb *db, const char *key);

/**
 * PTTL key
 */
int64_t redlite_pttl(struct RedliteDb *db, const char *key);

/**
 * EXPIRE key seconds
 */
int redlite_expire(struct RedliteDb *db, const char *key, int64_t seconds);

/**
 * PEXPIRE key milliseconds
 */
int redlite_pexpire(struct RedliteDb *db, const char *key, int64_t milliseconds);

/**
 * EXPIREAT key unix_timestamp
 */
int redlite_expireat(struct RedliteDb *db, const char *key, int64_t unix_seconds);

/**
 * PEXPIREAT key unix_timestamp_ms
 */
int redlite_pexpireat(struct RedliteDb *db, const char *key, int64_t unix_ms);

/**
 * PERSIST key
 */
int redlite_persist(struct RedliteDb *db, const char *key);

/**
 * RENAME key newkey
 */
int redlite_rename(struct RedliteDb *db, const char *key, const char *newkey);

/**
 * RENAMENX key newkey
 */
int redlite_renamenx(struct RedliteDb *db, const char *key, const char *newkey);

/**
 * KEYS pattern
 */
struct RedliteStringArray redlite_keys(struct RedliteDb *db, const char *pattern);

/**
 * DBSIZE
 */
int64_t redlite_dbsize(struct RedliteDb *db);

/**
 * FLUSHDB
 */
int redlite_flushdb(struct RedliteDb *db);

/**
 * SELECT db
 */
int redlite_select(struct RedliteDb *db, int db_num);

/**
 * HSET key field value [field value ...]
 */
int64_t redlite_hset(struct RedliteDb *db,
                     const char *key,
                     const char *const *fields,
                     const struct RedliteBytes *values,
                     size_t count);

/**
 * HGET key field
 */
struct RedliteBytes redlite_hget(struct RedliteDb *db, const char *key, const char *field);

/**
 * HDEL key field [field ...]
 */
int64_t redlite_hdel(struct RedliteDb *db,
                     const char *key,
                     const char *const *fields,
                     size_t fields_len);

/**
 * HEXISTS key field
 */
int redlite_hexists(struct RedliteDb *db, const char *key, const char *field);

/**
 * HLEN key
 */
int64_t redlite_hlen(struct RedliteDb *db, const char *key);

/**
 * HKEYS key
 */
struct RedliteStringArray redlite_hkeys(struct RedliteDb *db, const char *key);

/**
 * HVALS key
 */
struct RedliteBytesArray redlite_hvals(struct RedliteDb *db, const char *key);

/**
 * HINCRBY key field increment
 */
int64_t redlite_hincrby(struct RedliteDb *db,
                        const char *key,
                        const char *field,
                        int64_t increment);

/**
 * HGETALL key
 * Returns alternating field-value pairs
 */
struct RedliteBytesArray redlite_hgetall(struct RedliteDb *db, const char *key);

/**
 * HMGET key field [field ...]
 */
struct RedliteBytesArray redlite_hmget(struct RedliteDb *db,
                                       const char *key,
                                       const char *const *fields,
                                       size_t fields_len);

/**
 * HSETNX key field value
 * Returns 1 if field was set, 0 if field already exists
 */
int redlite_hsetnx(struct RedliteDb *db,
                   const char *key,
                   const char *field,
                   const uint8_t *value,
                   size_t value_len);

/**
 * HINCRBYFLOAT key field increment
 * Returns result as string (caller must free), NULL on error
 */
char *redlite_hincrbyfloat(struct RedliteDb *db,
                           const char *key,
                           const char *field,
                           double increment);

/**
 * LPUSH key value [value ...]
 */
int64_t redlite_lpush(struct RedliteDb *db,
                      const char *key,
                      const struct RedliteBytes *values,
                      size_t values_len);

/**
 * RPUSH key value [value ...]
 */
int64_t redlite_rpush(struct RedliteDb *db,
                      const char *key,
                      const struct RedliteBytes *values,
                      size_t values_len);

/**
 * LPOP key [count]
 */
struct RedliteBytesArray redlite_lpop(struct RedliteDb *db, const char *key, size_t count);

/**
 * RPOP key [count]
 */
struct RedliteBytesArray redlite_rpop(struct RedliteDb *db, const char *key, size_t count);

/**
 * LLEN key
 */
int64_t redlite_llen(struct RedliteDb *db, const char *key);

/**
 * LRANGE key start stop
 */
struct RedliteBytesArray redlite_lrange(struct RedliteDb *db,
                                        const char *key,
                                        int64_t start,
                                        int64_t stop);

/**
 * LINDEX key index
 */
struct RedliteBytes redlite_lindex(struct RedliteDb *db, const char *key, int64_t index);

/**
 * LSET key index value
 */
int redlite_lset(struct RedliteDb *db,
                 const char *key,
                 int64_t index,
                 const uint8_t *value,
                 size_t value_len);

/**
 * LTRIM key start stop
 */
int redlite_ltrim(struct RedliteDb *db, const char *key, int64_t start, int64_t stop);

/**
 * LREM key count element
 * Returns number of elements removed
 */
int64_t redlite_lrem(struct RedliteDb *db,
                     const char *key,
                     int64_t count,
                     const uint8_t *element,
                     size_t element_len);

/**
 * LINSERT key BEFORE|AFTER pivot element
 * before: 1 for BEFORE, 0 for AFTER
 * Returns new length, -1 if pivot not found or on error
 */
int64_t redlite_linsert(struct RedliteDb *db,
                        const char *key,
                        int before,
                        const uint8_t *pivot,
                        size_t pivot_len,
                        const uint8_t *element,
                        size_t element_len);

/**
 * LPUSHX key element [element ...]
 * Returns new length or -1 on error
 */
int64_t redlite_lpushx(struct RedliteDb *db,
                       const char *key,
                       const struct RedliteBytes *values,
                       size_t values_len);

/**
 * RPUSHX key element [element ...]
 * Returns new length or -1 on error
 */
int64_t redlite_rpushx(struct RedliteDb *db,
                       const char *key,
                       const struct RedliteBytes *values,
                       size_t values_len);

/**
 * LMOVE source destination LEFT|RIGHT LEFT|RIGHT
 * wherefrom: 0 for LEFT, 1 for RIGHT
 * whereto: 0 for LEFT, 1 for RIGHT
 * Returns moved element or NULL on error/empty
 */
struct RedliteBytes redlite_lmove(struct RedliteDb *db,
                                  const char *source,
                                  const char *destination,
                                  int wherefrom,
                                  int whereto);

/**
 * LPOS key element [RANK rank] [COUNT count] [MAXLEN maxlen]
 * Returns array of positions (use -1 for not found)
 * rank: optional rank parameter (0 for None)
 * count: number of matches to return (0 for all matches)
 * maxlen: max elements to scan (0 for no limit)
 */
struct RedliteBytesArray redlite_lpos(struct RedliteDb *db,
                                      const char *key,
                                      const uint8_t *element,
                                      size_t element_len,
                                      int64_t rank,
                                      size_t count,
                                      size_t maxlen);

/**
 * SADD key member [member ...]
 */
int64_t redlite_sadd(struct RedliteDb *db,
                     const char *key,
                     const struct RedliteBytes *members,
                     size_t members_len);

/**
 * SREM key member [member ...]
 */
int64_t redlite_srem(struct RedliteDb *db,
                     const char *key,
                     const struct RedliteBytes *members,
                     size_t members_len);

/**
 * SMEMBERS key
 */
struct RedliteBytesArray redlite_smembers(struct RedliteDb *db, const char *key);

/**
 * SISMEMBER key member
 */
int redlite_sismember(struct RedliteDb *db,
                      const char *key,
                      const uint8_t *member,
                      size_t member_len);

/**
 * SCARD key
 */
int64_t redlite_scard(struct RedliteDb *db, const char *key);

/**
 * SPOP key [count]
 */
struct RedliteBytesArray redlite_spop(struct RedliteDb *db, const char *key, size_t count);

/**
 * SRANDMEMBER key [count]
 * If count is positive, returns up to count distinct elements
 * If count is negative, may return duplicates
 */
struct RedliteBytesArray redlite_srandmember(struct RedliteDb *db, const char *key, int64_t count);

/**
 * SDIFF key [key ...]
 */
struct RedliteBytesArray redlite_sdiff(struct RedliteDb *db,
                                       const char *const *keys,
                                       size_t keys_len);

/**
 * SINTER key [key ...]
 */
struct RedliteBytesArray redlite_sinter(struct RedliteDb *db,
                                        const char *const *keys,
                                        size_t keys_len);

/**
 * SUNION key [key ...]
 */
struct RedliteBytesArray redlite_sunion(struct RedliteDb *db,
                                        const char *const *keys,
                                        size_t keys_len);

/**
 * SMOVE source destination member
 * Returns 1 if moved, 0 if member not in source
 */
int redlite_smove(struct RedliteDb *db,
                  const char *source,
                  const char *destination,
                  const uint8_t *member,
                  size_t member_len);

/**
 * SDIFFSTORE destination key [key ...]
 * Returns size of resulting set
 */
int64_t redlite_sdiffstore(struct RedliteDb *db,
                           const char *destination,
                           const char *const *keys,
                           size_t keys_len);

/**
 * SINTERSTORE destination key [key ...]
 * Returns size of resulting set
 */
int64_t redlite_sinterstore(struct RedliteDb *db,
                            const char *destination,
                            const char *const *keys,
                            size_t keys_len);

/**
 * SUNIONSTORE destination key [key ...]
 * Returns size of resulting set
 */
int64_t redlite_sunionstore(struct RedliteDb *db,
                            const char *destination,
                            const char *const *keys,
                            size_t keys_len);

/**
 * ZADD key score member [score member ...]
 */
int64_t redlite_zadd(struct RedliteDb *db,
                     const char *key,
                     const struct RedliteZMember *members,
                     size_t members_len);

/**
 * ZREM key member [member ...]
 */
int64_t redlite_zrem(struct RedliteDb *db,
                     const char *key,
                     const struct RedliteBytes *members,
                     size_t members_len);

/**
 * ZSCORE key member
 * Returns NaN if not found or on error
 */
double redlite_zscore(struct RedliteDb *db,
                      const char *key,
                      const uint8_t *member,
                      size_t member_len);

/**
 * ZCARD key
 */
int64_t redlite_zcard(struct RedliteDb *db, const char *key);

/**
 * ZCOUNT key min max
 */
int64_t redlite_zcount(struct RedliteDb *db, const char *key, double min, double max);

/**
 * ZINCRBY key increment member
 */
double redlite_zincrby(struct RedliteDb *db,
                       const char *key,
                       double increment,
                       const uint8_t *member,
                       size_t member_len);

/**
 * ZRANGE key start stop [withscores]
 * If withscores is true, returns alternating member-score pairs
 */
struct RedliteBytesArray redlite_zrange(struct RedliteDb *db,
                                        const char *key,
                                        int64_t start,
                                        int64_t stop,
                                        int with_scores);

/**
 * ZREVRANGE key start stop [withscores]
 * If withscores is true, returns alternating member-score pairs
 */
struct RedliteBytesArray redlite_zrevrange(struct RedliteDb *db,
                                           const char *key,
                                           int64_t start,
                                           int64_t stop,
                                           int with_scores);

/**
 * ZRANK key member
 * Returns rank (0-based), -1 if not found, -2 on error
 */
int64_t redlite_zrank(struct RedliteDb *db,
                      const char *key,
                      const uint8_t *member,
                      size_t member_len);

/**
 * ZREVRANK key member
 * Returns reverse rank (0-based), -1 if not found, -2 on error
 */
int64_t redlite_zrevrank(struct RedliteDb *db,
                         const char *key,
                         const uint8_t *member,
                         size_t member_len);

/**
 * ZRANGEBYSCORE key min max [offset count]
 * offset: number of elements to skip (use -1 for no offset)
 * count: max number of elements to return (use -1 for no limit)
 */
struct RedliteBytesArray redlite_zrangebyscore(struct RedliteDb *db,
                                               const char *key,
                                               double min,
                                               double max,
                                               int64_t offset,
                                               int64_t count);

/**
 * ZREMRANGEBYRANK key start stop
 * Returns number of elements removed
 */
int64_t redlite_zremrangebyrank(struct RedliteDb *db, const char *key, int64_t start, int64_t stop);

/**
 * ZREMRANGEBYSCORE key min max
 * Returns number of elements removed
 */
int64_t redlite_zremrangebyscore(struct RedliteDb *db, const char *key, double min, double max);

/**
 * GETBIT key offset
 * Returns bit value (0 or 1), or -1 on error
 */
int64_t redlite_getbit(struct RedliteDb *db, const char *key, uint64_t offset);

/**
 * SETBIT key offset value
 * Returns previous bit value (0 or 1), or -1 on error
 */
int64_t redlite_setbit(struct RedliteDb *db, const char *key, uint64_t offset, int value);

/**
 * BITCOUNT key [start end]
 * Returns number of set bits, or -1 on error
 */
int64_t redlite_bitcount(struct RedliteDb *db,
                         const char *key,
                         int64_t start,
                         int64_t end,
                         int use_range);

/**
 * BITOP operation destkey key [key ...]
 * Returns length of result string, or -1 on error
 * operation: "AND", "OR", "XOR", "NOT"
 */
int64_t redlite_bitop(struct RedliteDb *db,
                      const char *operation,
                      const char *destkey,
                      const char *const *keys,
                      size_t keys_len);

/**
 * SCAN cursor [MATCH pattern] [COUNT count]
 * Returns scan result with next cursor and keys
 */
struct RedliteScanResult redlite_scan(struct RedliteDb *db,
                                      const char *cursor,
                                      const char *pattern,
                                      size_t count);

/**
 * HSCAN key cursor [MATCH pattern] [COUNT count]
 * Returns scan result with next cursor and field-value pairs
 */
struct RedliteHScanResult redlite_hscan(struct RedliteDb *db,
                                        const char *key,
                                        const char *cursor,
                                        const char *pattern,
                                        size_t count);

/**
 * SSCAN key cursor [MATCH pattern] [COUNT count]
 * Returns scan result with next cursor and members
 */
struct RedliteSScanResult redlite_sscan(struct RedliteDb *db,
                                        const char *key,
                                        const char *cursor,
                                        const char *pattern,
                                        size_t count);

/**
 * ZSCAN key cursor [MATCH pattern] [COUNT count]
 * Returns scan result with next cursor and member-score pairs
 */
struct RedliteZScanResult redlite_zscan(struct RedliteDb *db,
                                        const char *key,
                                        const char *cursor,
                                        const char *pattern,
                                        size_t count);

/**
 * ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
 * Returns number of elements in result, or -1 on error
 * weights: optional array (NULL for default 1.0), must match keys_len if provided
 * aggregate: optional string "SUM", "MIN", or "MAX" (NULL for default SUM)
 */
int64_t redlite_zinterstore(struct RedliteDb *db,
                            const char *destination,
                            const char *const *keys,
                            size_t keys_len,
                            const double *weights,
                            size_t weights_len,
                            const char *aggregate);

/**
 * ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
 * Returns number of elements in result, or -1 on error
 * weights: optional array (NULL for default 1.0), must match keys_len if provided
 * aggregate: optional string "SUM", "MIN", or "MAX" (NULL for default SUM)
 */
int64_t redlite_zunionstore(struct RedliteDb *db,
                            const char *destination,
                            const char *const *keys,
                            size_t keys_len,
                            const double *weights,
                            size_t weights_len,
                            const char *aggregate);

/**
 * XADD key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold] *|ID field value [field value ...]
 * Returns generated stream ID, or NULL on error
 * If id_ms and id_seq are both 0, auto-generates ID (*)
 */
struct RedliteStreamId redlite_xadd(struct RedliteDb *db,
                                    const char *key,
                                    int64_t id_ms,
                                    int64_t id_seq,
                                    const struct RedliteStreamField *fields,
                                    size_t fields_len,
                                    int nomkstream,
                                    int64_t maxlen,
                                    int use_maxlen);

/**
 * XLEN key
 * Returns stream length, or -1 on error
 */
int64_t redlite_xlen(struct RedliteDb *db, const char *key);

/**
 * XRANGE key start end [COUNT count]
 * Returns stream entries in range, or empty array on error
 */
struct RedliteStreamEntryArray redlite_xrange(struct RedliteDb *db,
                                              const char *key,
                                              int64_t start_ms,
                                              int64_t start_seq,
                                              int64_t end_ms,
                                              int64_t end_seq,
                                              int64_t count,
                                              int use_count);

/**
 * XREVRANGE key end start [COUNT count]
 * Returns stream entries in reverse range
 */
struct RedliteStreamEntryArray redlite_xrevrange(struct RedliteDb *db,
                                                 const char *key,
                                                 int64_t end_ms,
                                                 int64_t end_seq,
                                                 int64_t start_ms,
                                                 int64_t start_seq,
                                                 int64_t count,
                                                 int use_count);

/**
 * XREAD [COUNT count] STREAMS key [key ...] id [id ...]
 * Note: This is a simplified version. Full XREAD with BLOCK is async-only.
 * For single-key reads with count. Use XRANGE for more control.
 */
struct RedliteStreamEntryArray redlite_xread(struct RedliteDb *db,
                                             const char *key,
                                             int64_t id_ms,
                                             int64_t id_seq,
                                             int64_t count,
                                             int use_count);

/**
 * XTRIM key MAXLEN [~] count
 * Returns number of entries deleted, or -1 on error
 */
int64_t redlite_xtrim(struct RedliteDb *db, const char *key, int64_t maxlen);

/**
 * XDEL key id [id ...]
 * Returns number of entries deleted, or -1 on error
 */
int64_t redlite_xdel(struct RedliteDb *db,
                     const char *key,
                     const struct RedliteStreamId *ids,
                     size_t ids_len);

/**
 * XGROUP CREATE key group id [MKSTREAM]
 * Returns 1 on success, 0 on error
 */
int redlite_xgroup_create(struct RedliteDb *db,
                          const char *key,
                          const char *group,
                          int64_t id_ms,
                          int64_t id_seq,
                          int mkstream);

/**
 * XGROUP DESTROY key group
 * Returns 1 if group was destroyed, 0 otherwise
 */
int redlite_xgroup_destroy(struct RedliteDb *db, const char *key, const char *group);

/**
 * XREADGROUP GROUP group consumer [COUNT count] STREAMS key id
 * Note: Simplified single-key version. Use ">" for id to get new messages.
 * Returns stream entries
 */
struct RedliteStreamEntryArray redlite_xreadgroup(struct RedliteDb *db,
                                                  const char *group,
                                                  const char *consumer,
                                                  const char *key,
                                                  const char *id,
                                                  int64_t count,
                                                  int use_count,
                                                  int noack);

/**
 * XACK key group id [id ...]
 * Returns number of messages acknowledged, or -1 on error
 */
int64_t redlite_xack(struct RedliteDb *db,
                     const char *key,
                     const char *group,
                     const struct RedliteStreamId *ids,
                     size_t ids_len);

/**
 * XGROUP SETID key group id
 * Returns 1 on success, 0 if group doesn't exist, -1 on error
 */
int64_t redlite_xgroup_setid(struct RedliteDb *db,
                             const char *key,
                             const char *group,
                             int64_t id_ms,
                             int64_t id_seq);

/**
 * XGROUP CREATECONSUMER key group consumer
 * Returns 1 if consumer was created, 0 if it already existed, -1 on error
 */
int64_t redlite_xgroup_createconsumer(struct RedliteDb *db,
                                      const char *key,
                                      const char *group,
                                      const char *consumer);

/**
 * XGROUP DELCONSUMER key group consumer
 * Returns number of pending messages consumer had, or -1 on error
 */
int64_t redlite_xgroup_delconsumer(struct RedliteDb *db,
                                   const char *key,
                                   const char *group,
                                   const char *consumer);

/**
 * XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]
 * Returns claimed stream entries
 */
struct RedliteStreamEntryArray redlite_xclaim(struct RedliteDb *db,
                                              const char *key,
                                              const char *group,
                                              const char *consumer,
                                              int64_t min_idle_time,
                                              const struct RedliteStreamId *ids,
                                              size_t ids_len,
                                              int64_t idle_ms,
                                              int64_t time_ms,
                                              int64_t retry_count,
                                              int force,
                                              int justid);

/**
 * XINFO STREAM key
 * Returns stream information or NULL on error
 */
struct RedliteStreamInfo *redlite_xinfo_stream(struct RedliteDb *db, const char *key);

/**
 * XINFO GROUPS key
 * Returns array of consumer group info
 */
struct RedliteConsumerGroupInfoArray redlite_xinfo_groups(struct RedliteDb *db, const char *key);

/**
 * XINFO CONSUMERS key group
 * Returns array of consumer info
 */
struct RedliteConsumerInfoArray redlite_xinfo_consumers(struct RedliteDb *db,
                                                        const char *key,
                                                        const char *group);

/**
 * GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]
 * Returns number of elements added
 */
int64_t redlite_geoadd(struct RedliteDb *db,
                       const char *key,
                       const struct RedliteGeoMember *members,
                       size_t members_len,
                       int nx,
                       int xx,
                       int ch);

/**
 * GEOPOS key member [member ...]
 * Returns array of positions
 */
struct RedliteGeoPosArray redlite_geopos(struct RedliteDb *db,
                                         const char *key,
                                         const char *const *members,
                                         size_t members_len);

/**
 * GEODIST key member1 member2 [M|KM|FT|MI]
 * unit: 0=M, 1=KM, 2=FT, 3=MI
 * Returns distance or -1.0 on error/not found
 */
double redlite_geodist(struct RedliteDb *db,
                       const char *key,
                       const char *member1,
                       const char *member2,
                       int unit);

/**
 * GEOHASH key member [member ...]
 * Returns array of geohash strings
 */
struct RedliteStringArray redlite_geohash(struct RedliteDb *db,
                                          const char *key,
                                          const char *const *members,
                                          size_t members_len);

/**
 * GEOSEARCH key FROMMEMBER member|FROMLONLAT lon lat BYRADIUS radius|BYBOX width height M|KM|FT|MI [ASC|DESC] [COUNT count] [WITHDIST]
 * Simplified: searches by radius from a point
 * from_member: if not NULL, search from this member; else use from_lon/from_lat
 * radius: search radius
 * unit: 0=M, 1=KM, 2=FT, 3=MI
 * count: limit results (0 for no limit)
 * withdist: 1 to include distance in results
 */
struct RedliteGeoMemberArray redlite_geosearch(struct RedliteDb *db,
                                               const char *key,
                                               const char *from_member,
                                               double from_lon,
                                               double from_lat,
                                               double radius,
                                               int unit,
                                               int64_t count,
                                               int withdist);

/**
 * GEOSEARCHSTORE dest source <GEOSEARCH args>
 * Returns number of elements stored
 */
int64_t redlite_geosearchstore(struct RedliteDb *db,
                               const char *dest,
                               const char *src,
                               const char *from_member,
                               double from_lon,
                               double from_lat,
                               double radius,
                               int unit,
                               int64_t count,
                               int store_dist);

/**
 * FT.CREATE - Simplified: create search index
 * For simplicity, this is a stub that returns success (full implementation complex)
 */
int64_t redlite_ft_create(struct RedliteDb *db, const char *index_name);

/**
 * FT.DROPINDEX - Drop search index
 */
int64_t redlite_ft_dropindex(struct RedliteDb *db, const char *index_name, int delete_docs);

/**
 * FT._LIST - List all search indexes
 */
struct RedliteStringArray redlite_ft_list(struct RedliteDb *db);

/**
 * FT.INFO - stub
 */
int64_t redlite_ft_info(struct RedliteDb *db, const char *_index);

/**
 * FT.ALTER - stub
 */
int64_t redlite_ft_alter(struct RedliteDb *db, const char *_index);

/**
 * FT.SEARCH - stub
 */
int64_t redlite_ft_search(struct RedliteDb *db, const char *_index, const char *_query);

/**
 * FT.ALIASADD - stub
 */
int64_t redlite_ft_aliasadd(struct RedliteDb *db, const char *_alias, const char *_index);

/**
 * FT.ALIASDEL - stub
 */
int64_t redlite_ft_aliasdel(struct RedliteDb *db, const char *_alias);

/**
 * FT.ALIASUPDATE - stub
 */
int64_t redlite_ft_aliasupdate(struct RedliteDb *db, const char *_alias, const char *_index);

/**
 * FT.SYNUPDATE - stub
 */
int64_t redlite_ft_synupdate(struct RedliteDb *db, const char *_index);

/**
 * FT.SYNDUMP - stub
 */
int64_t redlite_ft_syndump(struct RedliteDb *db, const char *_index);

/**
 * FT.SUGADD - stub
 */
int64_t redlite_ft_sugadd(struct RedliteDb *db,
                          const char *_key,
                          const char *_string,
                          double _score);

/**
 * FT.SUGGET - stub
 */
int64_t redlite_ft_sugget(struct RedliteDb *db, const char *_key, const char *_prefix);

/**
 * FT.SUGDEL - stub
 */
int64_t redlite_ft_sugdel(struct RedliteDb *db, const char *_key, const char *_string);

/**
 * FT.SUGLEN - stub
 */
int64_t redlite_ft_suglen(struct RedliteDb *db, const char *_key);

/**
 * HISTORY GET key [LIMIT limit] [SINCE timestamp] [UNTIL timestamp]
 * Returns array of history entries for the key
 */
struct RedliteHistoryEntryArray redlite_history_get(struct RedliteDb *db,
                                                    const char *key,
                                                    int64_t limit,
                                                    int64_t since,
                                                    int64_t until);

/**
 * HISTORY GETAT key timestamp
 * Returns value of key at a specific timestamp (time-travel query)
 */
struct RedliteBytes redlite_history_getat(struct RedliteDb *db, const char *key, int64_t timestamp);

/**
 * HISTORY LIST [PATTERN pattern]
 * Returns list of all keys that have history tracking enabled
 */
struct RedliteStringArray redlite_history_list(struct RedliteDb *db, const char *pattern);

/**
 * HISTORY STATS [key]
 * Returns statistics about history tracking
 * For now returns a simplified count as i64 (enhance later if needed)
 */
int64_t redlite_history_stats(struct RedliteDb *db, const char *key);

/**
 * HISTORY CLEAR key [BEFORE timestamp]
 * Clear history entries for a key, returns number of entries deleted
 */
int64_t redlite_history_clear(struct RedliteDb *db, const char *key, int64_t before);

/**
 * HISTORY PRUNE before_timestamp
 * Prune old history entries across all keys, returns number deleted
 */
int64_t redlite_history_prune(struct RedliteDb *db, int64_t before_timestamp);

/**
 * VACUUM - compact the database
 */
int64_t redlite_vacuum(struct RedliteDb *db);

/**
 * Get library version
 */
char *redlite_version(void);

#endif  /* REDLITE_H */
